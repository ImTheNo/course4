 \tikzstyle{pil}=[ ->,
	thick,
	shorten <=2pt,
	shorten >=2pt]

\tikzstyle{de} = [diamond, drawshade, top color=white,
    bottom color=blue!50!black!20, draw=blue!40!black!60, very
    thick, text centered, rounded corners, text width=6em, text badly centered, node distance=3cm, inner sep=0pt]

 \tikzstyle{decision} = [diamond, drawshade,  top color=white,
    bottom color=blue!50!black!20, draw=blue!40!black!60, very
    thick, text width=4.5em, text badly centered, node distance=3cm, inner sep=0pt]

 \tikzstyle{block} = [rectangle, draw,  text width=5em, text centered, minimum height=4em, top color=white,  bottom color=blue!50!black!20, draw=blue!40!black!60, very thick, rounded corners]

\tikzstyle{line} = [draw, -latex']
\tikzstyle{cloud} = [draw, ellipse,fill=red!20, node distance=3cm,
    minimum height=2em]
   
\tikzset{blue dotted/.style={draw=blue!50!white, line width=1pt,
                               dash pattern=on 1pt off 4pt on 6pt off 4pt,
                                inner sep=4mm, rectangle, rounded corners}}
\tikzstyle{blockwhite} = [rectangle, draw,  text width=5em, text centered, minimum height=4em, draw=white, fill=white]
\tikzstyle{bl} = [block, shade, top color=white,
    bottom color=blue!50!black!20, draw=blue!40!black!60, very
    thick, text width=10em, text centered, rounded corners, minimum height=4em]

\tikzstyle{step} = [ elipse, text width=5em, text centered, minimum height=4em,top color=white,
    bottom color=blue!50!black!20, draw=blue!40!black!60, very thick]

\bigskip 
\section{Введение.}

Механизмы разграничения доступа на уровне операционной
системы исторически представляют собой один из основных способов
обеспечения информационной безопасности, не менее
важный, чем криптография. Именно ядро операционной системы
и встроенные в него механизмы обеспечивают выполнение
кода процессов на аппаратуре и контролируют доступ
процессов к ресурсам.

Традиционной для UNIX-подобных систем является дискреционная модель
разграничения доступа. Та же модель применяется для системных сервисов в ОС
Android.

В 1985 году был введен стандарт «Критерии 
оценки доверенных компьютерных систем» более известный 
под названием «Оранжевая книга». Данный стандарт получил 
международное признание и оказал сильное влияние на 
последующие разработки в области информационной безопасности. 
Появилось семейство так называемых "trusted" операционных 
систем — TrustedBSD, Trusted Solaris, Trusted UNICOS 8.0, 
HP-UX 10.26, PitBull for AIX 5L, XTS-400. На сегодняшний 
день результатами разработки 
более современных и продвинутых систем безопасности, 
работающих поверх стандартных, стали такие продукты, как 
SELinux (NSA, Red Hat)~\cite{SEOF}, AppArmor (Immulinux, Novell) 
~\cite{AppArmor},
GRSecurity\cite{pax}, Seatbelt(Apple).

В случае SELinux контроль контроль основан на
описании набора типов объектов и субъектов, где для
каждого типа субъектов в явном виде описаны все разрешенные
операции над типами объектов. Во время запуска приложения
ему принудительно присваивается один из типов субъектов.

\textbf{Тип} -- это способ группировки сущностей на уровни
        секретности. Он может быть применен к файлам,
        каталогам и другим сущностям системы. Его можно
        представить как штамп конфиденциальности.
        Тип, присвоенный файлу, описывает уровень
        секретности данного файла и позволяет разрешить
        доступ только файлам, пользователям, ресурсам и т.д.
        с теми же или меньшими установками безопасности \cite{selinux2}.

\textbf{Объект} -- или системный объект это сущность,
        через которую информация проходит к субъекту.
        Это могут быть каталоги, файлы, поля, экраны,
        клавиатуры, память, магнитные накопители,
        принтеры или любые другие устройства хранения/перемещения
        данных. В сущности это контейнер данных или ресурс
        системы, доступ к объекту фактически означает доступ к данным \cite{selinux2}.

\textbf{Cубъект} -- это любая активная сущность, вызывающая
        перемещение информации между объектами, т.е.
        пользователь, пользовательский обработчик,
        системный процесс и т.д. \cite{selinux2}

Для каждого из типов субъектов работает принцип наименьших
привилегий, который гласит, что любой субъект в системе
должен иметь возможность получить доступ к тем и только к
тем объектам, которые ему необходимы для нормального
функционирования. Подобное решение оправдано,
так как на практике большинству приложений требуется лишь
небольшое подмножество привилегий, которыми обладает
пользователь. В результате компрометация приложения
злоумышленником не несет в себе угрозы целостности
и конфиденциальности данных пользователя, к которым не
имеет доступа скомпрометированное приложение. Это
существенное улучшение традиционной
модели безопасности, существующей в UNIX-подобных системах.

Реализованный в AppArmor и SELinux способ контроля предполагает
предоставление приложению одних и тех же привилегий с момента
запуска и до его завершения. При этом в большинстве приложений
на разных стадиях выполнения минимальный набор необходимых
привилегий может различаться. В качестве примера можно привести
сетевые приложения, где, как правило, доступ к файлам конфигурации
требуется только непосредственно после запуска приложения,
а в процессе авторизации пользователя нужен лишь доступ к сети и
объектам, необходимым для авторизации. После успешной авторизации
пользователя набор прав приложения, как правило, должен существенно
расшириться.

В результате, ограничения накладываемые на поведение приложений,
могут быть избыточными, но их невозможно сократить без потери
нормального функционирования приложения. Эта проблема приводит
к тому, что в случае компрометации приложения злоумышленнику удается
заполучить все привилегии данного приложения. В результате нарушается
конфиденциальность данных, к которым скомпрометированное приложение
имеет доступ с точки зрения реализованного в SELinux подхода.
Например, успешная атака на почтовый сервер позволит злоумышленнику
получить доступ к всем почтовым сообщениям, хранящимся на сервере даже
в случае контроля со стороны SELinux.

Несмотря на это, набор прав, предоставляемый субъектам 
и остающийся неизменным от момента запуска до остановки,
как правило, не является минимальным набором привилегий
для отдельных участков кода приложения.

Возникает идея повысить гранулярность контроля, осуществляемого SELinux,
перейдя от контроля поведения процессов к контролю поведения отдельных
участков кода процесса и динамическому изменению набора привилегий
приложения в зависимости от исполняемого в данный момент участка кода.
Данная идея была реализована в работах \cite{sacharov} и \cite{bush}. В
2012 году появилась первая рабочая версия проекта SEAndroid, ставящего
перед собой цель перенести SELinux на ОС для мобильных устройств
Android. В связи с этим было предложено опробовать динамическую смену
типа SELinux на мобильных платформах, используя SEAndroid.
 
\newpage
\section{Постановка задачи}

В работе необходимо исследовать возможность переноса ранее
разработанного расширения SELinux с контролем поведения на основе
динамического переключения контекстов в среду проекта SEAndroid.
Исследовать возможность реализации контрольных точек средствами ядра
SEAndroid на архитектуре ARM. Реализовать тестовое уязвимое приложение,
продемонстрировать работоспособность подсистемы защиты на эмуляторе.

\subsection{Детализация постановки}
Для решения поставленной задачи необходимо решить следующие подзадачи:
\begin{itemize}
\item Рассмотреть возможности платформы Android для динамической 
инструментации кода точками останова. Исследовать существующие
возможности ядра Linux в Android для решения данной задачи в версии для
платформы ARM.
\item Предложить план по портированию системы, описанной в
    работах \cite{sacharov} \cite{bush}, в ОС Android. Сделать
    реализацию.
\item Взять модельный пример сервиса, в котором будут явно выделены
    части, связанные с инициализацией ресурсов и обработкой запросов,
    пометить переходы между ними точками останова и показать
    работоспособность предложенного подхода. Все эксперименты достаточно
    проводить на эмуляторе.
\end{itemize}

\subsection{Ожидаемые результаты}
\begin{itemize}
\item Модуль ядра или патч к исходному коду, реализующий контроль
    поведения и переключение контекстов SELinux, желательно с
    минимальными модификациями кода ядра.
\end{itemize}
