 \tikzstyle{pil}=[ ->,
	thick,
	shorten <=2pt,
	shorten >=2pt]

\tikzstyle{de} = [diamond, drawshade, top color=white,
    bottom color=blue!50!black!20, draw=blue!40!black!60, very
    thick, text centered, rounded corners, text width=6em, text badly centered, node distance=3cm, inner sep=0pt]

 \tikzstyle{decision} = [diamond, drawshade,  top color=white,
    bottom color=blue!50!black!20, draw=blue!40!black!60, very
    thick, text width=4.5em, text badly centered, node distance=3cm, inner sep=0pt]

 \tikzstyle{block} = [rectangle, draw,  text width=5em, text centered, minimum height=4em, top color=white,  bottom color=blue!50!black!20, draw=blue!40!black!60, very thick, rounded corners]

\tikzstyle{line} = [draw, -latex']
\tikzstyle{cloud} = [draw, ellipse,fill=red!20, node distance=3cm,
    minimum height=2em]
   
\tikzset{blue dotted/.style={draw=blue!50!white, line width=1pt,
                               dash pattern=on 1pt off 4pt on 6pt off 4pt,
                                inner sep=4mm, rectangle, rounded corners}}
\tikzstyle{blockwhite} = [rectangle, draw,  text width=5em, text centered, minimum height=4em, draw=white, fill=white]
\tikzstyle{bl} = [block, shade, top color=white,
    bottom color=blue!50!black!20, draw=blue!40!black!60, very
    thick, text width=10em, text centered, rounded corners, minimum height=4em]

\tikzstyle{step} = [ elipse, text width=5em, text centered, minimum height=4em,top color=white,
    bottom color=blue!50!black!20, draw=blue!40!black!60, very thick]

\bigskip 
\section{Введение.}

Механизмы разграничения доступа на уровне операционной
системы исторически являются одним из основных способов
обеспечения информационной безопасности, не менее
важным, чем криптография. Именно ядро операционной системы
и встроенные в него механизмы обеспечивают выполнение
кода процессов на аппаратуре и контролируют доступ
процессов к ресурсам.

Традиционной для UNIX-подобных систем является дискреционная
модель разграничения доступа. 

В 1985 году был введен стандарт «Критерии 
оценки доверенных компьютерных систем» более известный 
под названием «Оранжевая книга». Данный стандарт получил 
международное признание и оказал сильное влияние на 
последующие разработки в области информационной безопасности. 
Появилось семейство так называемых "trusted" операционных 
систем — TrustedBSD, Trusted Solaris, Trusted UNICOS 8.0, 
HP-UX 10.26, PitBull for AIX 5L, XTS-400. На сегодняшний 
день результатами разработки 
более современных и продвинутых систем безопасности, 
работающих поверх стандартных, стали такие продукты, как 
SELinux (NSA, Red Hat)~\cite{SEOF}, AppArmor (Immulinux, Novell) 
~\cite{AppArmor},
GRSecurity\cite{pax}, Seatbelt(Apple).

В случае SELinux контроль контроль основан на
описании набора типов объектов и субъектов, где для
каждого типа субъектов в явном виде описаны все разрешённые
операции над типами объектов. Во время запуска приложения
ему принудительно присваивается один из типов субъектов.

Для каждого из типов субъектов работает принцип наименьших
привилегий, который гласит, что любой субъект в системе
должен иметь возможность получить доступ к тем и только к
тем объектам, которые ему необходимы для нормального
функционирования. Подобное решение является оправданным,
так как на практике большинству приложений требуется лишь
небольшое подмножество привилегий, которыми обладает
пользователь. В результате компрометация приложения
злоумышленником не несет в себе угрозы целостности
и конфиденциальности данных пользователя, к которым не
имеет доступа скомпрометированное приложение. Это является
существенным улучшением традиционной традиционной
модели безопасности, существующей в UNIX-подобных системах.

Реализованный в AppArmor и SELinux способ контроля предполагает
предоставление приложению одних и тех же привилегий с момента
запуска и до его завершения. При этом в большинстве приложений
на разных стадиях выполнения минимальный набор необходимых
привилегий может различаться. В качестве примера можно привести
сетевые приложения, где, как правило, доступ к файлам конфигурации
требуется только непосредственно после запуска приложения,
а в процессе авторизации пользователя нужен лишь доступ к сети и
объектам, необходимым для авторизации. После успешной авторизации
пользователя набор прав приложения, как правило, должен существенно
расшириться.

В результате, ограничения накладываемые на поведение приложений,
могут являться избыточными, но их невозможно сократить без потери
нормального функционирования приложения. Таким образом, возникает
идея динамически изменять набор привилегий приложения в зависимости
от состояния его исполнения.
 
\newpage
\section{Постановка задачи}
\begin{comment}
\subsection{Расшифровка темы}
Завершение работ 3 курса и работ Торощина,
Сапожникова, Горнак по отслеживанию поведения приложений со стороны ядра
ОС с помощью расстановки отладочных меток, сопоставления наблюдаемых
трасс с предварительно построенной моделью поведения и переключению
текущего профиля SELinux при изменениях состояния приложения.
Демонстрация reference implementation на примере популярного приложения
с искуственно внесённой уязвимостью. Публикация проекта.
\end{comment}

Разработать и реализовать набор инструментов для
разметки приложений (исходного кода и соответствующих бинарных программ)
контрольными точками (software breakpoints), разработать и реализовать
подсистему ядра Линукс, способную отслеживать поведение приложения в
виде последовательности системных вызовов и проходов через контрольные
точки, сопоставлять его с предварительно построенной автоматной моделью
и переключать активный профиль SELinux приложения при изменении его
состояния.

\begin{comment}
\subsection{Детализация постановки}
Для решения поставленной задачи необходимо решить следующие подзадачи:
\begin{itemize}
\item Разработать и реализовать набор инструментов для установки
контрольных точек в программе, а также динамической установки таких
точек в работающей программе.
\item Выбрать пример сетевого приложения, в котором: а) есть удалённо
эксплуатируемая уязвимость, б) данная уязвимость позволяет нарушить
конфиденциальность, целостность или доступность системы в случае
компрометации даже при наличии политики SELinux (контрпример к SELinux).
Показать, как можно расставить контрольные точки в данном приложении,
чтобы ущерб от атаки был минимальным.
\item Разработать и реализовать механизм наблюдения за поведением со
стороны ядра, отладить на выбранном примере сетевого приложения.
\item Опубликовать проект в публичном репозитории и в тематических списках
рассылки.
\end{itemize}

\subsection{Ожидаемые результаты}
\begin{itemize}
\item Набор утилит для расстановки контрольных точек, с использованием
результатов работы Татьяны Горнак прошлого года.
\item Набор модулей ядра, реализующий контроль поведения и переключение
контекстов SELinux, желательно с минимальными модификациями кода ядра.
\item Публичный репозиторий со всем, что необходимо стороннему пользователю
для того, чтобы воспользоваться результатами работы.
\end{itemize}

\end{comment}
\section{Формальная постановка задачи}

\subsection{Основные понятия и определения}
Обозначим: 

$\mathcal{S} - \text{множество системных вызовов,}$

$\mathcal{R} - \text{множество ресурсов системы.}$

Каждому ресурсу  соответствует конечный набор операций доступа, 
например, по открытию, чтению, записи и т.д. Такими операциями
доступа являются системные вызовы.

\textbf{Правило  SELinux для программы ($\mathcal{D}$)} -- отображение пары: системный вызов, ресурс на реакцию системы на правило:

$$\mathcal{D}: s \times r \to \{accept, decline\}, s \in \mathcal{S}, r \in \mathcal{R} \text{, где} $$\\
$accept$ -- разрешить выполнить системный вызов $s$ над ресурсом $r$,\\
$decline$ -- запретить выполнение.

\textbf{Модель программы} -- граф потока управления программы,
преобразованный таким образом, что его вершины представляют собой
различные участки программы, которым соответствует различное множество
наименьших привилегий, а переходы соответствуют переходам между данными
участками.

\textbf{Контрольная точка} -- Адрес в сегменте кода виртуального адресного
пространства процесса, попадание исполнения на который символизирует о
переходе модели программы в новое состояние.

\subsection{Постановка задачи}

Дано -- модель программы. Требуется:

\begin{itemize}
\item Разработать и реализовать набор инструментов для установки
контрольных точек в программе, а также динамической установки таких
точек в работающей программе.
\begin{comment}
\item Выбрать пример сетевого приложения, в котором: а) есть удалённо
эксплуатируемая уязвимость, б) данная уязвимость позволяет нарушить
конфиденциальность, целостность или доступность системы в случае
компрометации даже при наличии политики SELinux (контрпример к SELinux).
Показать, как можно расставить контрольные точки в данном приложении,
чтобы ущерб от атаки был минимальным.
\end{comment}
\item Разработать и реализовать механизм наблюдения за поведением со
стороны ядра, отладить на выбранном примере сетевого приложения.
\item Продемонстрировать работу реализованной системы на сетевом приложении,
    в котором существует:
    \begin{itemize}
    \item удалённо эксплуатируема уязвимость
    \item данная уязвимость позволяет нарушить конфиденциальность, целостность
        или доступность системы в случае компрометации даже при наличии политики
        SELinux
    \end{itemize}
\end{itemize}

\section{Обзор существующих систем безопасности 
    уровня ядра ОС Linux и ОС Trusted BSD}

\bigskip
Сравним системы безопасности уровня ядра ОС Linux
(SELinux, AppArmor, GRSecurity) и Trusted BSD. 
Для сравнительного анализа были выбраны следующие 
критерии:

\bigskip
{\bfseries Реализованные модели безопасности.} 

    Существуют различные модели безопасности такие, 
    как Дискреционная(DAC), Мандатная(MAC), Принудительное 
    присвоение типов на основании определенной 
    политики(TE), Списки контроля доступа(ACL). 
    Данный критерий отражает реализованные 
    в рассматриваемой системе модели безопасности.  

\bigskip
{\bfseries Наличие возможности изменять матрицу доступа 
	во время исполнения.}
	
	Во многих из упомянутых выше моделях безопасности 
	котроль событий в системе осуществляется на основании 
	матрицы доступа. Матрица доступа является отображением 
	декартова произведения множеств объектов и субъектов 
	системы на множество, элементами которого являются 
	наборы прав.
	Критерий отражает, есть ли возможность изменять
	матрицу доступа во время исполнения. 

\bigskip 
{\bfseries Возможность динамической смены контекстов
	приложения.}
	
	Для учета внутреннего состояния приложения в 
	процессе контроля за его поведением может быть
	использована динамическая смена конекста безопасности 
	 приложения. 
	Критерий описывает, существует ли в рассматриваемой 
	системе возможность менять права приложения в процессе
	исполнения. 

\bigskip
{\bfseries Классы вредоносных действий, предотвращаемых 
	системой безопасности.}
	
	Разные системы безопасности предотвращают различные 
	классы вредоносных действий. Некоторые системы 
	идут по пути предотвращения заранее известных 
	действий злоумышленника, другие позволяют минимизировать 
	нанесенный ущерб от успешной атаки. Из-за этого на практике 
	часто приходится комбинировать различные системы безопасности.    

\bigskip
\subsection{SELinux} 
SELinux является системой безопасности 
уровня ядра Linux, основанной на 
подсистеме LSM. LSM позволяет 
создавать модули безопасности. Данные модули 
должны реализовывать 
определенную логику принятия решений о 
разрешении или запрещении различных 
взаимодействий между объектами и субъектами 
системы. 

Под объектами системы здесь 
понимаются файлы, объекты межпрограммного 
взаимодействия, объекты сетевого взаимодействия 
и прочие. Субъекты представляют собой 
пользовательские процессы, демоны, ядро и.т.д..

SElinux обеспечивает возможность 
комплексной защиты системы, ограничивая поведение 
приложений и пользователей в рамках политик 
безопасности. В первую очередь, SELinux 
направлена на борьбу с успешными атаками, 
в частности, с атаками нулевого дня, когда 
уязвимость уже известна злоумышленнику, 
но лекарства еще не было выпущено. В таких 
случаях уязвимость локализируется на уровне 
политики. Компания Tresys ведет подсчет 
конкретных случаев угроз безопасности, которые, 
в частности, могли быть предотвращены SELinux. 
В их числе: переполнение буфера в Samba (may 
2007), Apache DoS (jun 2007), Mambo exploit (jul 
2007), hplip Security flaw (oct 2007). 

Конфигурация политик является 
сложной задачей из-за необходимости
описывать профили для каждого приложения 
вручную на на специальном языке описания
политик. Добавление новых профилей может повлечь 
за собой необходимость в модификации уже имеющихся 
профилей, что может привести к появлению 
ошибок и росту накладных расходов на 
администрирование системы.  

\subsubsection {Реализованные модели безопасности. } 

Принудительное присвоение типов (TE). 

Основной идеей принудительного присвоения
типов является явная разметка всех объектов 
в системе специальными структурами данных 
(метками безопасности), хранящими в себе информацию
об атрибутах объекта, используемую при принятии 
решений внутри логики политики. 
Для процессов и объектов используется 
один и тот же тип атрибутов. Поэтому достаточно 
одной матрицы для описания взаимодействий между 
разными типами, при этом объекты одного типа могут 
рассматриваться по-разному, если их их ассоциированные 
классы безопасности различны. Пользователи не 
привязаны к типам безопасности напрямую, вместо 
этого используется RBAC.

\bigskip
Ролевой контроль доступа (RBAC) 

Данный метод используется для определения 
множества ролей, которые могут 
быть назначены пользователям. SELinux расширяет 
модель RBAC до жесткой привязки пользовательских 
ролей к определенным доменам безопасности, роли 
могут быть организованы в виде иерархии приоритетов. 
Такая привязка ролей к доменам позволяет принимать 
большинство решений на основе конфигурации TE. 
Контекст безопасности, кроме всего прочего, включает 
в себя атрибут роли.

\bigskip
Многоуровневая система безопасности (MLS) 

SELinux предоставляет MLS для случаев, когда есть 
необходимость в традиционной многоуровневой системе 
безопасности. У объектов и субъектов могут быть 
различные уровни и категории. 
Как правило, используется лишь один уровень. 

\subsubsection{Наличие возможности изменять матрицу доступа 
	во время исполнения} 

SELinux Предоставляет возможность перезагружать 
	политику во время работы системы. 

\subsubsection{Возможность динамической смены контекстов 
приложения} 
 
SELinux предоставляет разработчикам приложений 
инструментарий, позволяющий создавать более 
безопасные приложения. Этого можно достичь 
путем изменения текущих привилегий приложения 
во время его исполнения. 
Последнее реализуется путем изменения домена приложения. 
Приложение должно запросить у ядра ОС смену своего 
текущего домена на указанный. При этом возможность
такой смены доменов должна быть явно описана в 
политике безопасности. Далее данный метод будет
рассмотрен более подробно.  

\subsubsection{Классы вредоносных действий, предотвращаемых 
	системой безопасности} 

В отношении системы безопасности SELinux было бы неправильно 
говорить о предотвращении угроз. Кроме этого, система не 
оперирует классами угроз. Основной идеей SELinux является 
минимизация ущерба от успешных атак на приложение. Для 
этого накладываются жесткие рамки на поведение приложений. 


\begin{comment}
\subsubsection{Принципы работы}

Главными элементами системы безопасности 
являются субъект, объект и действия. В классы 
объектов входят классы файлов (blk\_file, chr\_
file, dir, fd,...\ ) ,  классы межпрограммного 
взаимодействия (ipc,msg,msgq,sem,shm), классы 
сетевого взаимодействия (key\_socket,netif,node,
packet\_socket,tcp\_socket), классы объектов 
(passwd), системные классы (capability, process,
Secutity, System). Под субъектами понимаются 
процессы, демоны, ядро и.т.д.. Действия, которые субъекты 
SELinux могут производить над объектами 
различны для различных классов объектов. 
Для классов файлов это, например, 
будут создание, исполнение, ссылки, чтение, запись, 
удаление. 

SELinux ассоциирует атрибуты безопасности 
с субъектами и объектами и основывает свои решения 
на этих атрибутах. Атрибутами являются: идентификатор 
пользователя, роль и тип. Идентификатор пользователя 
— пользовательская учетная запись, ассоциированная с 
субъектом или объектом. У каждого пользователя может 
быть несколько ролей, но в какой-то конкретный момент
времени ему может быть предписана только одна из них. 
Пользователь может менять роли командой newrole. Типы 
(для процессов~--- Домены) делят субъекты и объекты на родственные 
группы. Это~--— главный атрибут безопасности, используемый 
SELinux для принятия решений. 

Типы позволяют помещать 
процессы в "песочницы" и предотвращать повышение 
привилегий. К примеру, роль суперпользователя - 
sysadm\_r, его тип — sysadm\_t. Политика безопасности 
SELinux загружается системой из бинарного файла политики,
который, как правило, находится в /etc/selinux. 
Бинарная политика собирается при помощи make, исходные 
коды, как правило, находятся в /etc/selinux/\$(POLNAME)/src/policy.

Инструменты работы с SELinux могут быть разделены на 
три категории: специальные утилиты для настройки и 
использования SELinux, модифицированные версии стандартных 
команд и программ Linux, некоторые добавочные инструменты,
к примеру, для настройки и анализа политик. Среди основных 
команд можно выделить следующие: chcon – помечает файл или 
группу файлов указанным контекстом безопасности, checkpolicy
– позволяет выполнять множество действий, связанных с 
политиками, в том числе, компиляцию политики и ее загрузку 
в ядро; getenforce — позволяет узнать в каком режиме 
работает SELinux, newrole – позволяет пользователю 
перемещаться между ролями; run\_init — позволяет 
запускать, останавливать или контролировать сервис; 
setenforce позволяет менять режим работы системы; 
setfiles присваивает метки указанной директории и ее 
поддиректориям. Некоторые из измененных программ: cron, 
login, logrotate, pam, ssh. Некоторые инструменты: Apol 
– инструмент для анализа файла policy.conf; SeAudit – 
инструмент для анализа логов, имеющий графический интерфейс; 
SeCmds; SePCuT — инструмент для просмотра и редактирования 
файлов политик; SeUser — модификация пользовательских 
учетных записей. 
\end{comment}

\subsubsection{Вывод}

