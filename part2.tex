\section{Обзор существующих систем контроля доступа в ОС Android и Linux}

\bigskip
Сравним системы контроля доступа для приложений в ОС Android.
Родственная природа Android и GNU/Linux позволяет также рассуждать о
более широком круге систем контроля доступа, а именно представленных в
Linux, но отсутствующих в Android. Для рассмотрения были выбраны Unix
DAC, SELinux, TOMOYO и XManDroid. Для сравнительного анализа были
выбраны следующие критерии:

\bigskip
{\bfseries Реализованные модели безопасности.} 

    Существуют различные модели безопасности такие, как
    Дискреционная(DAC), Мандатная(MAC), Принудительное присвоение типов
    на основании определенной политики(TE), Списки контроля
    доступа(ACL).  Данные модели были определены в \cite{orangebook} и
    являются де-факто стандартами при описании систем безопасности.

\bigskip
{\bfseries Наличие возможности изменять матрицу доступа 
	во время исполнения.}
	
    Во многих из упомянутых выше моделях безопасности контроль событий в
    системе осуществляется на основании матрицы доступа. Матрица доступа
    это отображение декартова произведения множеств объектов и субъектов
    системы на множество, элементами которого являются наборы прав.
    Критерий отражает, есть ли возможность изменять матрицу доступа во
    время исполнения. 

\bigskip
{\bfseries Классы вредоносных действий, предотвращаемых 
	системой безопасности.}
	
    Разные системы безопасности предотвращают различные классы
    вредоносных действий. Некоторые системы идут по пути предотвращения
    заранее известных действий злоумышленника, другие позволяют
    минимизировать нанесенный ущерб от успешной атаки. Из-за этого на
    практике часто приходится комбинировать различные системы
    безопасности.    

\bigskip
\subsection{Unix DAC} 
Контроль доступа на основе Дискреционной модели безопасности является
классическим способом разграничения привилегий в UNIX-подобных системах.
В основе подхода лежит принадлежность объектов в системе некоторым
субъектам, называемым владельцами объекта. Именно владелец объекта 
определяет права на доступ к своему объекту другим пользователям в
системе. Объект также принадлежит определённой группе пользователей, но
никто из них не имеет привилегий владельца.

В UNIX существует 3 группы пользователей для которых владелец
может определить права доступа: для владельца, для владеющей группы
и для всех остальных пользователей. Права на доступ к объекту делятся на
3 вида: права на чтение, запись и исполнение. Такое распределение можно
объяснить тем, что каждый объект в UNIX имеет интерфейс, подобный тому,
что есть у файлов: из файла можно прочитать содержимое, можно записать,
а можно исполнить записанную в нём программу. Помимо определения прав
доступа, владелец может передать свои права владения другому
пользователю или определить новую владеющую группу. Для доступа
приложения к специальным операциям, пользователю могут быть
гарантированы права из UNIX capabilities. Предоставляются возможности
для смены своего UID (пользователь может стать другим пользователем),
права на обход проверки привилегий чтения, записи и исполнения,
возможности по созданию файлов устройств, возможность посылать пакеты в
обход стека tcp/ip (т.е. в обход стандартных системных вызовов,
генерирующих заголовки tcp/ip), выполнение chroot, монтирование файловых
систем, отладка процессов и др. 

Доступ к объекту приложениям предоставляется следующим образом: каждое
исполняемое в системе приложение имеет эффективный идентификатор
пользователя, который определяет, от имени какого пользователя
исполняется данное приложение; когда приложение запрашивает у системы
некоторый ресурс(например, посредством системного вызова), последняя
определяет связанный с ресурсом объект, а также под какую группу прав
подпадает запрашиваемый доступ, затем в матрице доступа по паре
пользователь-объект определяется запись, где содержатся допустимые
права, если запрошенный доступ соответствует разрешённому, то система
предоставляет приложению доступ к ресурсу, иначе выдаёт сообщение об
ошибке.

В системе также имеется специальный пользователь, называемый root,
имеет права супер-пользователя, т.е. может выполнять любые действия над
объектами вне зависимости от их принадлежности. Также пользователю root
делегированы особые права, невозможные для получения другими
пользователями. Сюда входит например возможность, создавать слушающее
соединение на сетевых портах из диапазона 1-1024, который считается
зарезервированным за основными протоколами. Так как некоторым
пользовательским приложениям порой бывают нужны такие права, UNIX DAC
даёт право супер-пользователю выставлять так называемый SetUID-бит для
объекта системы: приложение, запускаемое из такого объекта владеет
правами супер-пользователя, при этом владельцем объекта остаётся обычный
пользователь, а значит он может запускать данное приложение.

\subsubsection {Реализованные модели безопасности.} 

Как следует из названия UNIX DAC реализует только дискреционную модель
безопасности. В рамках данной модели пользователи сами устанавливают
политики доступа к своим объектам.

\subsubsection{Наличие возможности изменять матрицу доступа 
	во время исполнения} 

Пользователи могут в изменять права на доступ к объекту и передавать
право владения другим пользователям.

\subsubsection{Классы вредоносных действий, предотвращаемых 
	системой безопасности} 

Система предназначена для минимизации ущерба в случае успешных атак на
приложение. Однако в части сохранения секретности данных отдельных
пользователей могут наблюдаться проблемы. Основной принцип дискреционной
модели направлен на баланс между безопасностью и простотой
администрирования, ведь ответственность за объекты пользователей
оставлена на их совести. Если пользователь неправильно определит права
на доступ к объекту из вне, то возможны успешные атаки на
конфиденциальность. Модель также плоха в окружениях, где требуется
жёсткий контроль администратора, например в системах, где уровень
секретности данных, с которыми работают пользователи высок. В случае
атак по сговору пользователь системы может нарочно ослабить защищённость
секретной информации. Общая простота модели с файловыми объектами и 3
группами прав также несёт в себе опасность, так как нет возможности
более тонко ограничить права приложений. Такая простота приводит к тому,
что системным сервисам, решающим важные задачи функционирования системы
(сетевые серверы, мониторинг и логгирование, ipc, БД) приходится выдавать
права root для их нормального функционирования. Успешные атаки на
root-приложения приводят к существенным проблемам при эксплуатации их
привилегий. 

\bigskip
\subsection{SELinux} 

SELinux система контроля доступа, работающая на уровне ядра операционной
системы. Допустимые права приложений определяются на основе политик
безопасности. В задачу системы входит ограничение прав работающих
приложений для минимизации ущерба от атак. SELinux даёт централизованный
контроль над каждым исполняемым приложением и работает по принципу "что
не разрешено, то запрещено". Одним из главных преимуществ использования
SELinux является широкая описательная возможность политик безопасности,
которая позволяет задавать доступ к ресурсам по принципу минимальных
привилегий. SELinux базируется на Linux Security Modules (LSM, более
подробно см. в \cite{LSM}), эта система отвечает за отслеживание всех
точек доступа к ресурсам операционной системы через так называемые
"хуки" в системных вызовах.  При попадании исполнения системного вызова
на такой хук, LSM выполняет проверку прав доступа приложения на
возможность выполнения этого системного вызова сначала через
классическую систему Дискреционного Контроля Доступа (DAC), а затем
обращается к SELinux.

Модель SELinux оперирует следующими основными понятиями: 
\begin{description}
    \item{Тип} \hfill \\
        Определяет группу сущностей(процессов, файлов, сокетов и т.д.).
        Для процессов тип имеет специальное название — \emph{Домен}. На
        основе политики безопасности в SELinux определяется какие
        операции представители одного типа могут производить над
        представителям другого.  
    \item{Объект}  \hfill \\
        Сущность, через которую информация проходит к субъекту. Это
        могут быть каталоги, файлы, поля, экраны, клавиатуры, память,
        магнитные накопители, принтеры или любые другие устройства
        хранения/перемещения данных. В сущности это контейнер данных или
        ресурс системы, доступ к объекту фактически означает доступ к
        данным.  
    \item{Cубъект}  \hfill \\
        Любая активная сущность, вызывающая перемещение информации между
        объектами, т.е.  пользователь, пользовательский обработчик,
        системный процесс и т.д.  
    \item{Атрибут}  \hfill \\
        Абстракция операции или группы операций, которые субъект может
        выполнить над объектом, например, чтение процессом файла.  
    \item{Политика безопасности}  \hfill \\
        Набор правил определяющих возможности доступа субъектов к
        объектам. Правила представляются в виде тройки \{тип субъекта, тип
        объекта, атрибут\}. С помощью политик SELinux в системе можно
        реализовывать доступ на основе подходов разных формальных
        моделей безопасности: Role-Based Access Control (RBAC), Type
        Enforcement (TE), Multi-Level Security (MLS). TE является
        наиболее популярной в последнее время.   
    \item{Контекст}  \hfill \\
        Элемент правила политики безопасности, определяющий тип
        сущности. В случае TE это понятие эквивалентно типу.
\end{description}

Общий алгоритм принятия решений о предоставлении
доступа(проиллюстрирован на рисунке \ref{fig:selarch}): 
\begin{itemize}
\item Процесс пытается выполнить операцию над объектом 
\item Сервер принятия решений получает уведомление от LSM о попытке
    провести операцию, получает контексты субъекта и объекта, а также
    атрибут операции от LSM и передаёт эту информацию серверу политики в
    виде запроса 
\item Сервер политики сначала проверяет в кэше наличие решения для
    такого запроса: разрешить или запретить операцию. Если решение
    найдено оно возвращается серверу принятия решения. Иначе ищется
    соответствующее правило в политике безопасности и на основе его
    принимается решение, помещается в кэш и опять же возвращается
    серверу принятия решений. Если правила не найдено то принимается
    решение запретить 
\item Сервер принятия решений на основе информации от сервера политики
    либо запрещает исполнение операции приложением (в этом случае,
    например, системный вызов аварийно завершается с кодом ошибки), либо
    позволяет продолжение выполнения операции 
\end{itemize}

\subsubsection{Политика SELinux} 

В качестве примера политики SELinux можно привести
фрагмент политики приложения OpenSSH.

\lstinputlisting[label=samplecode13,caption=Пример конфигурации модуля SELinux]{sourceCode/sepol.txt}
В данном фрагменте описывается тип процесса ssh\_t и
набор привилегий, предоставляемых данному типу:
\begin{itemize}
\item Set capability
\item Отлаживать процессы типа ssh\_t, исполнять свои сегменты
        кучи и стека
\item Использовать очереди сообщений
\item Отправлять и посылать сообщения
\item Использовать сокеты
\end{itemize}

Политики позволяет описывать права на доступ к широкому ряду ресурсов
ОС. Гранулярность языка позволяет разрешать и запрещать выполнять
определённые системные вызовы по отношению к объектам системы. В
качестве объектов могут указываться файлы, устройства, сокеты, сетевые
порты, сетевые интерфейсы, ipc, файловые системы.  Правила политики
SELinux определяют неизменный набор привилегий для процесса с
соответствующим типом. Для изменения набора привилегий процессу
необходимо сменить тип, т.е. контекст. SELinux предоставляет для этого
несколько возможностей. Первая может быть определена в политике через
ключевое слово \emph{domain transition}. Такое правило определяет для
процесса возможность исполнять приложение другого типа (совершать
системный вызов execve). После того как новое приложение начнёт
исполнение, тип процесса будет изменён. Вторая возможность
предоставляется только для типов, у которых в политике задан атрибут
\emph{setattr}. Процессы такого типа могут совершать изменение своего
типа на любой другой, определённый в политике, с помощью библиотеки
libselinux.  Как видно, в политиках SELinux нет возможности описать
динамическое изменение привилегий процесса для произвольного типа.

\subsubsection {Реализованные модели безопасности.} 
SELinux реализует Мандатную модель безопасности, при это доступны к
применению различные её вариации:

Принудительное присвоение типов (TE). 

При таком подходе каждый объект и субъект в системе получает
принудительный идентификатор, который в дальнейшем используется для
принятия решений на основе политики. Данный идентификатор используется
для записи допустимых прав в политики безопасности. В TE субъектами
являются непосредственно приложения, а не пользователи которые их
запускают. В SELinux такой идентификатор называется типом для объектов и
доменом для приложений.  Типы всегда относятся к определённым классам,
которые определяют природу абстрактного ресурса, т.е. класс типа говорит
о том, какие с данным типом возможны операции. Также при описании
допустимого доступа между доменом и объектом может дополнительно
указываться класс, для чёткого описания природы взаимодействия, ведь
один и тот же объект может принадлежать разным классам, в которых
определены операции с одинаковыми по написанию, но различными по
действию операциями.

\bigskip
Ролевой контроль доступа (RBAC) 

Данный метод используется для определения множества ролей, которые могут
быть назначены пользователям. SELinux расширяет модель RBAC до жесткой
привязки пользовательских ролей к определенным доменам безопасности,
роли могут быть организованы в виде иерархии приоритетов.  

\bigskip
Многоуровневая система безопасности (MLS) 

SELinux предоставляет MLS для случаев, когда есть 
необходимость в традиционной многоуровневой системе 
безопасности. У объектов и субъектов могут быть 
различные уровни и категории. 
Как правило, используется лишь один уровень. 

\subsubsection{Наличие возможности изменять матрицу доступа 
	во время исполнения} 

Пользователи могут в изменять права на доступ к объекту и передавать
право владения другим пользователям.

\subsubsection{Классы вредоносных действий, предотвращаемых 
	системой безопасности} 

В отношении системы безопасности SELinux было бы неправильно 
говорить о предотвращении угроз. Кроме этого, система не 
оперирует классами угроз. Основной идеей SELinux является 
минимизация ущерба от успешных атак на приложение. Для 
этого накладываются жесткие рамки на поведение приложений. 

\bigskip
\subsection{TOMOYO Linux} 
TOMOYO Linux позволяет реализовать мандатный контроль доступа в системе
на основе анализа нормального поведения приложений и последующей
генерации политик безопасности. Реализованный в 2003 году, в качестве
Linux Security Module, TOMOYO Linux прошёл несколько ревизий, на данный
момент актуальной является версия 2.5. TOMOYO Linux предлагает
анализировать необходимые приложению ресурсы, а затем по собранной
информации сгенерировать политику безопасности, которая уже затем в
режиме MAC будет ограничивать его права в системе. В режиме обучения
TOMOYO Linux записывает информацию обо всех ресурсах которые приложение
запрашивает. Далее данный список анализируется составителем политик и
если все требования удовлетворены, генерируется политика.

Субъектами в TOMOYO являются процессы. Каждый процесс обладает доменом
исполнения, который определяет его права. Домен складывается из "истории
исполнения", т.е. из всех приложений, которые данный процесс исполнял,
включая историю потомков процесса. Приложение же идентифицируется по
пути в файловой системе его исполнительного файла (например, /sbin/ip).

Права же определяются в профилях. Чтобы предоставить права домену, нужно
добавить этот домен в профиль. Права могут задаваться над объектами,
описываемыми своим путём в файловой системе. Список возможных прав
включает в себя файловые операции (создание, удаление, чтение, запись,
исполнение, создание директорий, ссылок, фалов устройств, ipc),
монтирование файловых систем, chroot, операции с сетью. Для упрощения
работ с политиками используются исключения, применяемые вне зависимости
от того, какие профили управляют данным доменом.

\subsubsection {Реализованные модели безопасности.} 

В TOMOYO Linux реализована Мандатная модель безопасности.

\subsubsection{Наличие возможности изменять матрицу доступа 
	во время исполнения} 

История исполнения влияет доступные права, так что приложение может
иметь различные права. Есть возможность менять политику безопасности в
процессе исполнения.

\subsubsection{Классы вредоносных действий, предотвращаемых 
	системой безопасности} 

TOMOYO Linux прежде всего направлен на изучению требуемых приложениям
ресурсов, он также позволяет минимизировать ущерб в случае успешной
атаки, путём предоставления минимальных привилегий.


\bigskip
\subsection{XManDroid} 

XManDroid был предложен в \cite{xmandroid} и представляет собой систему
безопасности для Android, чьей целью является предотвращение атак по
сговору и атак типа confused deputy, при которых зловредное действие
может быть осуществлено силами нормального приложения, имеющего
необходимые права в системе, но обманным путём принуждённого к
совершению такового. Решение представляет собой комбинацию системного
монитора, выявляющего пути следования данных между приложениями,
политики безопасности, описывающие безопасные шаблоны поведения для
приложений, а также система MAC непосредственно гарантирующая права по
результатам решений системного монитора.  Системный монитор действует на
всех уровнях системы, отслеживая коммуникации через файлы и сокеты, ipc
и БД. При этом отслеживаются как прямые, так и связи через
представителей. Система динамически поддерживает информацию о связях
между приложениями, и каждый раз когда приложение выдаёт новый запрос на
взаимодействие с другим приложением, данный запрос оценивается на
соответствие политикам безопасности с учётом состояния системы, т.е.
предыдущих актов взаимодействия. Если системный монитор выявляет, что
данный запрос с учётом состояния системы не соответствует политике, то
доступ не предоставляется. В ином случае состояние системы обновляется,
отображая установленную связь. Мониторинг и обновление состояния
происходит как на уровне фреймворка приложений, так и на уровне ядра.

\subsubsection {Реализованные модели безопасности.} 

Используется Мандатная модель безопасности. При этом права на доступ
определяются не монолитно, а на основе действий приложений и сверки
с политиками безопасности, но сами политики применяются централизованно
и устанавливаются администратором.

\subsubsection{Наличие возможности изменять матрицу доступа 
	во время исполнения} 

Матрица доступа может меняться, в зависимости от состояния системы.

\subsubsection{Классы вредоносных действий, предотвращаемых 
	системой безопасности} 

XManDroid адресует атаки по сговору и confused deputy.

\begin{comment}

SELinux~--- система безопасности 
уровня ядра Linux, основанная на 
подсистеме LSM. LSM позволяет 
создавать модули безопасности. Данные модули 
должны реализовывать 
определенную логику принятия решений о 
разрешении или запрещении различных 
взаимодействий между объектами и субъектами 
системы. 

Под объектами системы здесь 
понимаются файлы, объекты межпрограммного 
взаимодействия, объекты сетевого взаимодействия 
и прочие. Субъекты представляют собой 
пользовательские процессы, демоны, ядро и.т.д..

SElinux обеспечивает возможность 
комплексной защиты системы, ограничивая поведение 
приложений и пользователей в рамках политик 
безопасности. В первую очередь, SELinux 
направлена на борьбу с успешными атаками, 
в частности, с атаками нулевого дня, когда 
уязвимость уже известна злоумышленнику, 
но лекарства еще не было выпущено. В таких 
случаях уязвимость локализируется на уровне 
политики. Компания Tresys ведет подсчет 
конкретных случаев угроз безопасности, которые, 
в частности, могли быть предотвращены SELinux. 
В их числе: переполнение буфера в Samba (may 
2007), Apache DoS (jun 2007), Mambo exploit (jul 
2007), hplip Security flaw (oct 2007). 

Конфигурация политик является 
сложной задачей из-за необходимости
описывать профили для каждого приложения 
вручную на на специальном языке описания
политик. Добавление новых профилей может повлечь 
за собой необходимость в модификации уже имеющихся 
профилей, что может привести к появлению 
ошибок и росту накладных расходов на 
администрирование системы.  

Схема работы SELinux заключается в следующем.
Имеется политика, описывающая типы объектов
и субъектов в системе и матрицу доступа,
содержащую для каждого из субъектов его права
на операции с любым из типов объектов. Когда
любой из процессов производит системный вызов
для доступа к какому-либо объекту, подсистема
ядра SELinux вычисляет, имеет ли тип данного процесса
права на доступ к типу запрашиваемого объекта.
Если таких прав нет, запрашивающему процессу
будет отказано в доступе к объекту. В противном
случае, доступ к объекту будет предоставлен.
Схематично работа SELinux изображена на рисунке
\ref{fig:selinux}.

\subsubsection {Реализованные модели безопасности.} 

Принудительное присвоение типов (TE). 

Основная идея принудительного присвоения
типов~--- явная разметка всех объектов 
в системе специальными структурами данных 
(метками безопасности), хранящими в себе информацию
об атрибутах объекта, используемую при принятии 
решений внутри логики политики. 
Для процессов и объектов используется 
один и тот же тип атрибутов. Поэтому достаточно 
одной матрицы для описания взаимодействий между 
разными типами, при этом объекты одного типа могут 
рассматриваться по-разному, если их их ассоциированные 
классы безопасности различны. Пользователи не 
привязаны к типам безопасности напрямую, вместо 
этого используется RBAC.

\bigskip
Ролевой контроль доступа (RBAC) 

Данный метод используется для определения 
множества ролей, которые могут 
быть назначены пользователям. SELinux расширяет 
модель RBAC до жесткой привязки пользовательских 
ролей к определенным доменам безопасности, роли 
могут быть организованы в виде иерархии приоритетов. 
Такая привязка ролей к доменам позволяет принимать 
большинство решений на основе конфигурации TE. 
Контекст безопасности, кроме всего прочего, включает 
в себя атрибут роли.

\bigskip
Многоуровневая система безопасности (MLS) 

SELinux предоставляет MLS для случаев, когда есть 
необходимость в традиционной многоуровневой системе 
безопасности. У объектов и субъектов могут быть 
различные уровни и категории. 
Как правило, используется лишь один уровень. 


\subsubsection{Наличие возможности изменять матрицу доступа 
	во время исполнения} 

SELinux Предоставляет возможность перезагружать 
	политику во время работы системы. 

\subsubsection{Возможность динамической смены контекстов
приложения} 
 
SELinux предоставляет разработчикам приложений 
инструментарий, позволяющий создавать более 
безопасные приложения. Этого можно достичь 
путем изменения текущих привилегий приложения 
во время его исполнения. 
Последнее реализуется путем изменения домена приложения. 
Приложение должно запросить у ядра ОС смену своего 
текущего домена на указанный. При этом возможность
такой смены доменов должна быть явно описана в 
политике безопасности. Далее данный метод будет
рассмотрен более подробно.  

\subsubsection{Классы вредоносных действий, предотвращаемых 
	системой безопасности} 

В отношении системы безопасности SELinux было бы неправильно 
говорить о предотвращении угроз. Кроме этого, система не 
оперирует классами угроз. Основной идеей SELinux является 
минимизация ущерба от успешных атак на приложение. Для 
этого накладываются жесткие рамки на поведение приложений. 

\section{Обзор SELinux и SEAndroid}

\newpage

\subsubsection{Принципы работы}

Главными элементами системы безопасности 
являются субъект, объект и действия. В классы 
объектов входят классы файлов (blk\_file, chr\_
file, dir, fd,...\ ) ,  классы межпрограммного 
взаимодействия (ipc,msg,msgq,sem,shm), классы 
сетевого взаимодействия (key\_socket,netif,node,
packet\_socket,tcp\_socket), классы объектов 
(passwd), системные классы (capability, process,
Secutity, System). Под субъектами понимаются 
процессы, демоны, ядро и.т.д.. Действия, которые субъекты 
SELinux могут производить над объектами 
различны для различных классов объектов. 
Для классов файлов это, например, 
будут создание, исполнение, ссылки, чтение, запись, 
удаление. 

SELinux ассоциирует атрибуты безопасности 
с субъектами и объектами и основывает свои решения 
на этих атрибутах. Атрибутами являются: идентификатор 
пользователя, роль и тип. Идентификатор пользователя 
— пользовательская учетная запись, ассоциированная с 
субъектом или объектом. У каждого пользователя может 
быть несколько ролей, но в какой-то конкретный момент
времени ему может быть предписана только одна из них. 
Пользователь может менять роли командой newrole. Типы 
(для процессов~--- Домены) делят субъекты и объекты на родственные 
группы. Это~--— главный атрибут безопасности, используемый 
SELinux для принятия решений. 

Типы позволяют помещать 
процессы в "песочницы" и предотвращать повышение 
привилегий. К примеру, роль суперпользователя - 
sysadm\_r, его тип — sysadm\_t. Политика безопасности 
SELinux загружается системой из бинарного файла политики,
который, как правило, находится в /etc/selinux. 
Бинарная политика собирается при помощи make, исходные 
коды, как правило, находятся в /etc/selinux/\$(POLNAME)/src/policy.

Инструменты работы с SELinux могут быть разделены на 
три категории: специальные утилиты для настройки и 
использования SELinux, модифицированные версии стандартных 
команд и программ Linux, некоторые добавочные инструменты,
к примеру, для настройки и анализа политик. Среди основных 
команд можно выделить следующие: chcon – помечает файл или 
группу файлов указанным контекстом безопасности, checkpolicy
– позволяет выполнять множество действий, связанных с 
политиками, в том числе, компиляцию политики и ее загрузку 
в ядро; getenforce — позволяет узнать в каком режиме 
работает SELinux, newrole – позволяет пользователю 
перемещаться между ролями; run\_init — позволяет 
запускать, останавливать или контролировать сервис; 
setenforce позволяет менять режим работы системы; 
setfiles присваивает метки указанной директории и ее 
поддиректориям. Некоторые из измененных программ: cron, 
login, logrotate, pam, ssh. Некоторые инструменты: Apol 
– инструмент для анализа файла policy.conf; SeAudit – 
инструмент для анализа логов, имеющий графический интерфейс; 
SeCmds; SePCuT — инструмент для просмотра и редактирования 
файлов политик; SeUser — модификация пользовательских 
учетных записей. 
\end{comment}
