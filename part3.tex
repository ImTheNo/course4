\section{Исследование и построение решения задачи}
\label{issled}

\subsection{Обзор архитектуры Android}
\subsubsection{Программный Стек}
\label{androidDesc}

ОС Android -- широко распространённая платформа на рынке мобильных
устройств. Здесь рассматривается программный стек Android, т.е. уровни
ОС, предоставляющие интерфейсы одним компонентам системы и использующие
возможности других. Android работает на базе распространённой ОС Linux, 
ядро Android по сути является ядром Linux с небольшими изменениями и
оптимизациями. Это значит, что большинство классических функций
операционных систем (такие как файловые системы, планирование процессов,
управление памятью) в Android реализуется также, как в Linux. 

\begin{figure}
\centering
\subfloat{\label{fig:android_arch}\includegraphics[width=140mm]{external/typical-schematic-of-android_structure.png}} 
\caption{Иллюстрация программного стека Android}
\end{figure}

Далее рассмотрим основные уровни программного стека Android,
изображённые на рисунке \ref{fig:android_arch}:

\textbf{Приложения} : пользовательские приложения, написанные на java,
распространяемые через AndroidMarket или через APK-файлы. Сюда можно
отнести почтовые клиенты, браузеры, медиа-проигрователи и другие
приложения, которыми пользователь обычно пользуется непосредственно
взаимодействуя с ними. 

\textbf{Фреймворк уровня приложений} : набор java классов и пакетов,
предоставляющих API для написания приложений. Набор предоставляемой
функциональности довольно широк: от управления жизненным циклом
приложения до элементов пользовательского интерфейса. Здесь же
предоставляются интерфейсы для взаимодействия приложений друг с другом,
использования одним приложением функций другого.

\textbf{Системные библиотеки} : Набор c/c++ библиотек, применяемых для
написания приложений в Android. Доступны приложениям через фреймворк.
Данные библиотеки реализуют различные ресурсоёмкие задачи, решение
которых посредством java-библиотек вылилось бы в проблемы с
производительностью. В набор входят библиотеки для работы с различными
медиа-форматами (png, jpg, mp3, H.264 и другие), базами данных (sqlite), 
шрифтами, стандартная библиотека с/c++ (Android использует собственную
вариацию под названием bionic), opengl для рисование графики, webkit для
написания web-браузеров. 

\textbf{Android Runtime} : Android использует собственную java-машину
Dalvik Virtual Machine для исполнения java-приложений. DVM используется
из соображений ограниченного объёма памяти на мобильных устройствах. Для
эффективной реализации sandbox-ов для приложений, сущности DVM
запускаются специальным процессом zygote. Также на этом уровне находятся
различные системные сервисы и демоны, работающие с ядром ОС,
устройствами и т.д., например vold, adbd, usbd.

\textbf{Ядро Linux} : В Android используется частично изменённая версия
ядра Linux (обычно используются стабильные ветки ядра 2.6),
оптимизированная под специфику мобильных устройств. Здесь реализуются
драйвера различных физических устройств, системы контроля доступа,
алгоритмы управления виртуальной памятью, файловые системы, сетевой
стек.

В данной работе нас будет интересовать именно ядро Linux. Рассмотрим в
следующем разделе изменения, которые вносит Android в ядро Linux, и на
корелляцию между версиями Linux в Android и в ОС GNU/Linux.

\subsubsection{Сравнения ядер Android и GNU/Linux}

Ядро Linux подходит для использования на самых разных платформах:
встроенные системы, реального времени, высоконагруженные системы и
обычные персональные компьютеры. Когда Linux адаптировался для Android
пришлось вносить изменения в ядро для оптимизации некоторых аспектов
межпроцессного взаимодействия, а также делать поправки на особенности
загрузки ОС на разных устройствах.

Android активно используют передачу данных между процессами, а также
даёт возможность процессам организовать свои процедуры RPC (Remote
Procedure Call). Стандартные средства IPC Linux недостаточно эффективны
для обработки частых запросов на передачу данных, поэтому в Android
появляется существует собственный механизм IPC - Binder. Данный
компонент состоит из нескольких частей: драйвер ядра, реализующий
эффективную передачу данных через общее для всех процессов пространство
ядра, и подсистема рантайма, которая обрабатывает все запросы процессов
на IPC и выполняет их на уровне системных вызовов (взаимодействие с
драйвером).

Система ashmem разделяемой памяти вводит несколько иной, более
эффективный на мобильных устройствах подход, чем классический POSIX SHM.
Вместо файлового API, ashmem позволяет выделять участки разделяемой
памяти с использованием системного вызова mmap, с аргументом файловым
дескриптором, открытым на специальном устройстве /dev/ashmem. Так ashmem
способен отслеживать все области разделяемой памяти в системе, и
уничтожать неиспользуемые в случае нехватки памяти.

В числе прочих изменений, внесённых разработчиками Android можно
упомянуть pmem, аллокатор физической памяти, разделяемой между кодом
ядра и пользовательского пространства, logger реализующий общий
интерфейс логгирования для всех процессов, файловая система yaffs2,
различные патчи, уменьшающие потребление электроэнергии и ещё несколько
архитектурно-зависимых изменений.

По ситуации на март 2013 года, в проекте SEAndroid ядро соответствует 
версии 3.4 обычного ядра Linux.

\subsection{Обзор существующей реализации динамической смены SELinux
контекстов}

\subsubsection{Общая схема работы решения}

Реализация сделана в виде набора изменений основного ядра Linux,
позволяющих из модулей ядра производить динамическое изменение
контекстов безопасности любых процессов в системе и модуля ядра,
которое, собственно, является наблюдающей системой. Проект был назван
apathy.

В наблюдающую систему из пользовательского пространства передается
информация об адресах контрольных точек, информация об изменениях
контекстов безопасности связанных с этими контрольными точками и
информация о том, к какому приложению каждая из точек относится. Вся эта
информация передаётся посредством системных вызовов ioctl, производимых
на специальном устройстве /dev/apathy, которое регистрирует модуль во
время инициализации. Обработчик системного вызова заносит информацию о
смене контекста и целевом приложении в свои внутренние структуры данных. 
Устройстве /dev/apathy зарегистрировано в виде обычного символьного
устройства.

Далее, в процессе работы система отслеживает все порождения новых
процессов в системе. Если у системы имеется информация относительно
необходимости установки контрольных точек в данный процесс, она
производит установку контрольных точек и начинает наблюдение за ходом
исполнения данного процесса. В случае если процесс порождает новые
процессы, то система устанавливает контрольные точки в их пространство и
наблюдает за ними. Если же процесс завершается или начинает исполнять
другое приложение (посредством вызова exec), контрольные точки снимаются
и наблюдательная система прекращает отслеживание процесса. Для
отслеживания всех описанных событий система apathy из \cite{bush} и
\cite{sacharov} использовала трассировщик системных вызовов utrace
\cite{utrace}. В utrace для установки отладчика нужно было
зарегистрировать специальный "движок", через который происходило
взаимодействие с отладчиком. Для установки такого движка в интересующий
процесс использовалась система kprobes, которая позволяла
инструментировать код функций ядра точками останова. Спомощью kprobes
система могла отслеживать все вызовы exec, проверять, нуждается ли
запускаемое приложение в контрольных точках и если да, то устанавливала
отладчик utrace, который уже впоследствии заботился об установке и
снятии точек.

Контрольные точки реализованы в виде точек останова (breakpoint в
терминологии отладочного ПО). При попадании контрольного потока на такую
точку, в системе вызывается специальный обработчик, который определяет,
подходящий контекст и осуществляет переключение. Задачу инструментации
кода точками останова в приложение решает система uprobes.  Установка
точек производится заменой инструкции по требуемому адресу на инструкцию
отладочного прерывание (int3 в x86). Прежняя инструкция xol-исполняется
после того, как контрольный поток дошёл до точки останова и
ассоциированный обработчик отработал. XOL означает executed-out-of-line,
т.е. подменяемая инструкция копируется в специальную область памяти и
исполняется уже оттуда. Uprobes был реализован только для архитектур x86
и powerpc.

Для переключения контекстов использовались функции SELinux. В ядре
контекст процесса хранится в виде целого числа в специальной структуре
task\_security\_struct. Для трансляции контекста в число использовалась
функция security\_context\_to\_sid. Структура task\_security\_struct
треда хранилась в структуре cred текущего треда, для работы с ней
использовались макросы prepare\_creds и commit\_creds.

Помимо уже описанных подсистем в apathy использовались различные
примитивы синхронизации и макросы для работы со связанными списками.

\subsubsection{Возможности интеграции существующей реализации с
SEAndroid}

Как уже было сказано в \ref{androidDesc}, ядро Android по сути является
ядром Linux, поэтому теоретически можно портировать систему apathy,
описанную в \cite{sacharov} и \cite{bush} при условии, что все
необходимые фреймворки и интерфейсы реализованы в версии Linux на
Android. По ситуации с ядром версии 3.4 в проекте SEAndroid в коде
проекта имеется всё необходимое для переноса apathy за исключением
uprobes и utrace. 

\bigskip
{\bfseries Utrace.}

\bigskip
На момент работ, описанных в \cite{sacharov} оба фреймворка носили
экспериментальный характер, были совместимы только со специальными
версиями Linux. После того как в 2010 году сообщество разработчиков
Linux отклонило предложение о включении utrace в основной пакет поставки
Linux проект прекратил своё существование. Поэтому на данный момент не
представляется разумным адаптировать код utrace к Linux 3.4. 

\bigskip
{\bfseries Uprobes.}

\bigskip
Похожая история произошла и с uprobes, что привело к решению
разработчиков о пересмотре API и контекстов использования. Раньше
uprobes был pid-based, т.е. точки останова регистрировались на один
процесс. В последней же версии uprobes перешёл на концепт inode-based,
сейчас точки регистрируются на индексный дескриптр в файловой системе
(не следует путать с путём в VFS).  Именно эта версия была принята в
основную ветку разработки Linux. Сейчас uprobes в основном используется
в координации с perf events, подсистемой профилировки приложений.
Функциональность uprobes не экспортируется для использования в
загружаемых модулях (LKM).  Фреймворк uprobes был включён в основную
ветку Linux начиная с версии 3.5.4, поэтому его нету в SEAndroid. Однако
различиями между версиями можно пренебречь, они не внесут сложностей в
процесс переноса uprobes из Linux 3.5.4 в Linux 3.4. Описанные
возможности inode-based uprobes позволяют отказаться от использования
utrace, ведь все те же вещи для которых в нашем проекте использовался
utrace, теперь реализуются спомощью uprobes. Отпала необходимость
отслеживать все запускаемые в ОС приложения, теперь это делает uprobes,
и проводит инструментацию кода, когда есть зарегистрированные точки
останова для данного приложения.

\subsubsection{Вывод}

На данный момент (май 2013) существуют только экспериментальная версия
uprobes для архитектуры ARM, собрать которую на Android на данный момент
не представляется возможным в силу различий версий Linux и uprobes
(кросс-платформенной части) в  SEAndroid и GNU/Linux. Однако по
заявлениям разработчиков, планируется выпустить стабильную версию порта.
Исходя из этих заявлений не представляется разумным отказываться от
использования uprobes в нашем проекте с SEAndroid. Реализация проекта
подобного uprobes своими силами не представляется возможной с точки
зрения ограниченного времени и здравого смысла. Поэтому было принято
решение в данной работе перенести x86 uprobes на SEAndroid, подготовить
платформо-независимую реализацию apathy в SEAndroid и тесты проводить на
x86. Для реализации можно переработать уже существующий код смены
контекстов и обработчиков для точек останова. Задачи по написанию кода
реализации:

\begin{itemize}

\item Отказаться от использования utrace и kprobes в проекте, убрать
    весь код связанный с отслеживанием процессов спомощью этих
    фреймворков.

\item Вместо использования utrace устанавливать контрольные точки
    из ядерного модуля, использую функционал uprobes в момент
    конфигурации.

\item Экспортировать все необходимые функции SELinux и uprobes

\item Реализация возможности конфигурации из пользовательского
        пространства должна сохранится в прежнем виде
        
\end{itemize}

\begin{comment}
\subsubsection{О ещe одном подходе к выделению
        набора контрольных точек из программы}

В работе~\cite{gornak}
рассматривается средство автоматизации 
построения нормального поведения приложений при помощи
построения автомата безопасности.  Построение 
состояний автомата реализуется при помощи выделения 
блоков кода, соответствующих различным внутренним 
состояниям приложения. 

Тестирование разработанного средства производилось 
на приложении ftpd со следующим набором команд: 

\begin{itemize}
\item DELE -- удалить файл,
\item HELP -- выводит список команд принимаемых сервером,
\item LIST -- возвращает список файлов,
\item NOOP -- пустая операция,
\item QUIT -- отключиться,
\item SYST -- возвращает тип системы,
\item SHOW -- выдать список файлов с описаниями,
\item DESC -- добавить описание файла,
\item TYPE -- установить тип передачи файла (бинарный, текстовый),
\item STOR -- закачать файл,
\item ABOR -- прервать выполнение команды,
\end{itemize}

Основная особенность данного приложения ~--- наличие 
анонимных и авторизованных пользователей. Действия, 
которые разрешено выполнять этим группам пользователей
различаются. 

На рисунке приведен граф потока управления рассматриваемого 
приложения. 

\begin{figure}
 %\centering
  \scalebox{.35}{\input{miniftp_controlflow1.tex}}
  \scalebox{.35}{\input{miniftp_controlflow2.tex}}
\caption{Свертка и выделение блоков. Демонстрация шагов алгоритма}
\end{figure}


Итоговое разбиение. Блок 10 соответствует операциям, 
которые может производить анонимный пользователь, 
9 соответствует тем операциям, которые может производить 
авторизованный пользователь.

\begin{figure}
\centering
\scalebox{.80}{\input{finalresult.tex}}
\caption{Итоговое разбиение} 
%\label{fig:finalres} 
\end{figure}


На основании полученного разбиения код приложения размечается
контрольными точками. Контрольная точка ставится на входе 
в каждый блок и на выходе из него. Далее работа с этими 
контрольными точками и связанной с ними информацией о смене 
контекстов производится в описанном ниже режиме.
\end{comment}

\begin{comment}
\subsection{Обзор общих принципов работы рассматриваемых 
систем безопасности.} 

\bigskip
\paragraph{SELinux.}

\bigskip
{\bfseries Основные понятия. }

Принудительное присвоение типов (TE). 
И для процессов и для объектов используется 
один и тот же тип атрибутов. Поэтому достаточно 
одной матрицы достаточно для описания доступа к 
взаимодействию между разными типами, при этом 
объекты одного типа могут рассматриваться по-разному, 
если их их ассоциированные классы безопасности 
различны. Пользователи не привязаны к типам 
безопасности напрямую, вместо этого используется RBAC.

Ролевой контроль доступа (RBAC)  используется 
для определения множества ролей, которые могут 
быть назначены пользователям. SELinux расширяет 
модель RBAC до жесткой привязки пользовательских 
ролей к определенным доменам безопасности, роли 
могут быть организованы в виде иерархии приоритетов. 
Такая привязка ролей к доменам позволяет принимать 
большинство решений на основе конфигурации TE. 
Контекст безопасности кроме всего прочего включает 
в себя атрибут роли.

Многоуровневая система безопасности (MLS) 
SELinux предоставляет MLS для случаев, когда есть 
необходимость в традиционной многоуровневой системе 
безопасности. У объектов и субъектов могут быть 
различные уровни и категории. 
Как правило используется лишь один уровень. 

\bigskip
{\bfseries Практический обзор }

Главными элементами системы безопасности 
являются субъект, объект и действия. В классы 
объектов входят классы файлов (blk\_ file, chr\_ 
file, dir, fd,...\ ) ,  классы межпроцессного 
взаимодействия (ipc,msg,msgq,sem,shm), классы 
сетевого взаимодействия (key\_ socket,netif,node,
packet\_ socket,tcp\_ socket), классы объектов 
(passwd), системные классы (capability, process,
Secutity, System). Действия, которые субъекты 
SELinux могут предпринимать над объектами меняются
от класса к классу. Для классов файлов это, например, 
будут создание, исполнение, ссылки, чтение, запись, 
удаление. SELinux ассоциирует атрибуты безопасности 
с субъектами и объектами и основывает свои решения 
на этих атрибутах. Атрибутами являются: идентификатор 
пользователя, роль и тип. Идентификатор пользователя 
— пользовательская учетная запись, ассоциированная с 
субъектом или объектом. У каждого пользователя может 
быть несколько ролей, но в какой-то конкретный момент
времени ему может быть предписана только одна из них. 
Пользователь может менять роли командой newrole. Типы 
(а.к.а. Домены) делят субъекты и объекты на родственные 
группы. Это — главный атрибут безопасности, используемый 
SELinux для принятия решений. Типы позволяют помещать 
процессы в «песочницы» и предотвращать повышение 
привилегий. К примеру, роль суперпользователя - 
sysadm\_ r, его тип — sysadm\_ t. Политика безопасности 
SELinux загружается системой из бинарного файла политики,
который, как правило находится в /etc/security/selinux. 
Бинарная политика собирается при помощи make, исходные 
коды, как правило, находятся в /etc/security/selinux/src/policy.
Инструменты работы с SELinux могут быть разделены на 
три категории: специальные утилиты для настройки и 
использования SELinux, модифицированные версии стандартных 
команд и программ Linux, некоторые добавочные инструменты,
к примеру, для настройки и анализа политик. Среди основных 
команд можно выделить следующие: chcon – помечает файл или 
группу файлов указанным контекстом безопасности, checkpolicy
– позволяет выполнять множество действий, связанных с 
политиками, в том числе, компиляцию политики и ее загрузку 
в ядро; getenforce — позволяет узнать в каком режиме 
работает SELinux, newrole – позволяет пользователю 
перемещаться между ролями; run\_ init — позволяет 
запускать, останавливать или контролировать сервис; 
setenforce позволяет менять режим работы системы; 
setfiles присваивает метки указанной директории и ее 
поддиректориям. Некоторые из измененных программ: cron, 
login, logrotate, pam, ssh. Некоторые инструменты: Apol 
– инструмент для анализа файла policy.conf; SeAudit – 
инструмент для анализа логов, имеющий графический интерфейс; 
SeCmds; SePCuT — инструмент для просмотра и редактирования 
файлов политик; SeUser — модификация пользовательских 
учетных записей. 

\bigskip
{\bfseries Краткий обзор анатомии политики SELinux.}

Файлы политики организованы в виде дерева каталогов, 
корнем которого, как правило, является /etc/security/selinux/src/policy/. 
Основными поддиректориями являются: appconfig 
(определяет дефолтные типы контекстов безопасности); 
domains (определяют домены принудительного присвоения типов); 
file\_contexts (определяют контексты безопасности файлов), 
flask (определяет символы, испльзуемые ядром, совместимым 
с SELinux), macros (определяет макрос М4, используемый в 
исходных текстах политик), tmp (хранит сорцы политик во 
время компиляции), types (определяет несколько главных 
типов, которые не ассоциируются с конкретными доменами). 
Как правило существует два файла, которые определяют домен: 
FC file (file context), определяет контексты безопасности 
директорий и файлов, связанных с данным доменом); TE file 
(type enforcement, определяет вектор правил доступа и 
операций, связанных с доменом). Целью данного обзора не является. 

\bigskip
{\bfseries 5.2. AppArmor.}

AppArmor является системой безопасности, поддерживаемой 
компанией Novell, включена в дистрибутивы openSUSE и SUSE 
Enterprise. В AppArmor для определения того, к каким 
системным ресурсам и с какими привилегиями может 
получить доступ то или иное приложение используются 
политики безопасности (profiles). В отличие от SELinux, 
в которой настройки глобальны для всей системы, профили 
AppArmor разрабатываются индивидуально для каждого 
приложения. Изначально в AppArmor включен набор 
стандартных профилей, запускаемых после установки. 
Отдельно доступны профили для разных популярных программ 
и серверов. Кроме этого существуют инструменты для генерации 
профилей (genprof и logprof). Основная идея — верный выбор 
приложений, нуждающихся в ограничении привилегий и 
создание/редактирование профилей безопасности. Таким 
образом, в случае эксплойта, нанесенный ущерб сводится 
к минимуму. Система может работать в двух режимах: режиме 
обучения (complain) и в принудительном режиме (enforce). 
В первом из них все нарушения правил профиля разрешены, 
но немедленно регистрируются. Загрузка профиля в 
принудительном режиме предписывает системе отправлять 
сообщения о нарушениях в syslogd. Запуск и остановку 
AppArmor можно осуществлять при помощи команды rcapparmor 
с одним из следующих параметров: start (загрузка модуля 
ядра, анализ профиля, монтирование своей фс); stop (фс 
размонтируется, профили становятся недействительными); 
reload (перезагрузка профилей), status (информация о 
количестве запущенных профилей, в каком режиме они 
работают). Инструменты командной строки AppArmor: autodep 
(создает приблизительный профиль для программы или 
рассматриваемого приложения); complain (устанавливает 
профиль AppArmor в обучающий режим); enforce (переводит 
профиль в принудительный режим); genprof (генерирует профиль,
программа указывается при запуске); logprof (управляет
профилями AppArmor); unconfined (выводит список процессов 
с портами tcp и udp, которые не имеют загруженных 
профилей AppArmor). Система AppArmor построена на системе 
полных путей к файлам, проще говоря, типичное описание 
профиля выглядит примерно так: 

\bigskip
\begin{flushleft}
\texttt{\#include <tunables/global> \\  
/usr/bin/man { \\ 
	\#include <abstractions/base> \\
	\#include <abstractions/nameservice> \\
	capability setgid, \\
	capability setuid, \\
	/usr/lib/man-db/man Px,}\\ 
}
{\sloppy

}
\end{flushleft}

\bigskip
Профиль состоит из файлов, каталогов с указанием полных 
путей к ним и прав доступа к этим объектам. При этом r — 
разрешение на чтение, w — запись(за исключением создания 
и удаления файлов), ix — исполнение и наследование текущего 
профиля, px — исполнение под специфическим профилем, Px — 
защищенное выполнение, ux — неограниченное исполнение, 
Ux — защищенное неограниченное исполнение, m — присвоение 
участку памяти атрибута «исполняемый», I — жесткая ссылка. 
Чтобы подключить готовый профиль к AppArmor, достаточно его 
скопировать в каталог /etc/apparmor.d. 

\bigskip
{\bfseries PaX }

Основная цель данного проекта — изучение различных защитных 
механизмов, защищающих от эксплойтов уязвимостей ПО, которые 
предоставляют злоумышленнику полные права на чтение/запись в 
системе. Исполнение кода связано с необходимостью изменять 
ход выполнения процесса используя уже существующий код. Одна 
из основных проблем — подмена адресов возврата из функций и 
подмена самих адресов функций. Для установки PaX требуется 
наложить патч на дерево исходных кодов ядра, после чего собрать 
ядро и установить в систему. 

\bigskip
{\bfseries Trusted BSD.}

Проект TrustedBSD – проект разработки расширения существующей системы 
безопасности FreeBSD, включая расширенные атрибуты UFS2, 
списки контроля доступа, OpenPAM, аудит событий 
безопасности с OpenBSM, мандатное управление доступом 
и TrustedBSD MAC Framework. Trusted BSD была задумана 
как система, удовлетворяющая стандартам «оранжевой книги». 
Расширенные атрибуты UFS2 позволяют ядру и 
пользовательским процессам помечать файлы 
именованными метками. Это предоставляет место для 
хранение данные, необходимые системе безопасности, 
такие, как ACL и метки MAC. Списки контроля доступа 
— расширения дискреционного контроля доступа. Аудит 
системных событий позволяет вести избирательный 
логгинг важных системных событий для последующего 
анализа, обнаружения вторжений, и мониторинга в 
реальном времени. Начиная с версии 5.0 в ядре FreeBSD 
появилась поддержка MAC Framework, прошедшая испытания 
в TrustedBSD. Данный фреймворк позволяет создавать политики, 
определяющие принудительное присвоение доменов и типов (DTE), 
многоуровневую систему безопасности (MLS). Данный фреймворк 
предоставляет интерфейсы управления фреймворком, примитивы 
для синхронизации, механизм регистрации политик, примитивы 
для разметки объектов системы, разные политики, 
реализованные в виде модулей политики MAC и набор 
системных вызовов для приложений. При регистрации 
политики, происходит регистрация специальной структуры 
(struct mac\_policy\_ops), содержащей функции MAC 
framework, реализуемые политикой. На данный момент 
существуют следующие политики: 

mac\_biba – Реализация политики Biba, во многом 
схожей с MLS. Позволяет присваивать объектам и 
субъектам системы атрибуты доступа, которые образую 
иерархию уровней. Все операции над информацией в 
системе контролируются исходя из уровней 
взаимодействующих сущностей. 

mac\_ifoff позволяет администраторам контролировать 
сетевой трафик. 

mac\_lomac (Low-watermark MAC) еще одна 
реализация многоуровневого контроля доступа. 

mac\_bsdextended (file system firewall ) Система 
защиты файлов, основанная на определении прав 
доступа на основании роли пользователя. 

mac\_mls~--- реализация политики MLS. Объекты 
классифицируются  некоторым образом, субъектам 
присваивают уровень доступа. 

\bigskip
{\bfseries ОС «Феникс».}

ОС «Феникс» является отечественной разработкой — 
разработка СпбГУ, целью которой является создание 
специальной защищенной операционной системы класса 
Unix, отвечающей отечественным требованиям и 
стандартам информационной безопасности. «Феникс» 
представляет собой микроядерную, многопользовательскую, 
многозадачную, многопоточную операционную систему класса 
UNIX со встроенными механизмами защиты, 
обеспечивающими контроль взаимодействий, управление 
доступом, контроль целостности, 
идентификацию/аутентификацию пользователей 
и возможность подключения средств шифрования. 
Микроядерная архитектура отвечает принципу 
интегрированности, поскольку только в микроядерных 
системах для взаимодействий используется 
единственный способ — обмен сообщениями. 
Контроль доступа органично встраивается в этот 
механизм, причем, установив тотальный контроль 
над потоками сообщений, можно быть уверенным в 
том, что контролируются все взаимодействия в системе.
Принцип инвариантности определил организацию всех 
взаимодействий в «Феникс» на основе архитектуры 
клиент-сервер. В соответствии с принципом унификации 
доступ к объектам в «Феникс» осуществляется через 
Унифицированный Интерфейс Доступа к Объектам (УНИДО), 
определяющий множество операций, универсальных для 
всех типов объектов, в виде универсального набора 
методов, позволяющего выполнять все операции доступа к 
объектам, их создания и уничтожения, управления их
свойствами. Использование УНИДО единственный способ 
выполнения операций над объектами в «Феникс». 
Интерфейс оформлен в виде абстрактного класса, от 
которого наследуются интерфейсы всех серверов «Феникс», 
реализуемых УНИДО. Наличие набора типовых операций 
упрощает реализацию контроля доступа, поскольку 
определено однозначное соответствие между методами 
УНИДО и операциями доступа, описываемыми моделями 
безопасности. 

\bigskip
{\bfseries Vista Kernel-Mode Security.}

В ОС Windows Vista была расширена модель 
безопасности, присутствовавшая в предыдущих 
версиях системы(вплоть до XP SP2). Среди 
нововведений стоит отметить цифровые подписи 
драйверов, PatchGuard, Kernel-mode Code 
Integrity Checks, optional support for Secure 
Bootup using a TPM hardware chip, restricred 
user-mode access to \\ Device\\ PhysicalMemory. 

\bigskip
{\bfseries Driver Signing }. Анализируя эксплойты 
уязвимостей прошлых версий ОС, мы можем 
прийти к выводу, что наиболее распространенный 
способ, используемый вредоносным кодом для 
проникновения в ядро — проникновение через 
драйверы. Поэтому Vista не только требует подписи 
от драйвера, но и требует подпись именно от одного 
из восьми доверенных сертификатов. 

\bigskip
{\bfseries PatchGuard} был разработан для предотвращения 
патчей ядра ОС Виста х64. Защищает ядро путем периодической 
проверки на валидность некоторых структур данных и образов 
системы. PatchGuard кроется в NTOSKRNL.EXE и проверяет особо 
критичные системные структуры через случайные промежутки 
времени, обычно порядка 5-10 минут. Если была обнаружена 
модификация, «system will blue screen with the following 
bugcheck(which will obviously cause the user to lose all 
unsaved data)». (возможно ли обнаружить и убить тред 
PatchGuard?) 

\bigskip
Disabling \\Device\\PhysivalMemory 
Отказ от возможности доступа к Disabling \\ Device\\ PhysivalMemory 
из пользовательского пространства тоже является 
серьезным шагом на пути предотвращения доступа вредоносного кода к ядру. 

\bigskip
{\bfseries Code Integrity (CI.DLL) }
Импортируется статически NTOSKRNL. Защищает систему 
тем, что проверяет  системные исполняемые файлы на 
наличие изменений, в том числе и из-за внедрения 
вредоносного кода, наличие в системе неподписанных 
драйверов, запущенных в режиме ядра. В чем же отличие 
CI от PatchGuard, если они предоставляют схожую 
функциональность? CI может быть отключен, если 
отключены integrity checks, PatchGuard всегда включен. 
Кроме этого, эти методы разрабатывались разными 
командами внутри Microsoft и по заявлениям 
разработчиков, служат разным целям. 

\bigskip
{\bfseries Возможные направления атак. }
Kernel-Mode Network Drivers. 
Виста поддерживает некоторые сетевые протоколы 
в виде драйверов уровня ядра. Если уязвимость 
обнаружена в одном их этих подписанных драйверах, 
это бы дало возможность заполучить удаленный 
контроль над всей машиной. 

Disabling Driver Signing and Code Integrity 

Самый простой путь преодоления всех сложностей, 
связанных с подписями драйверов — патч исполняемых 
файлов и отключение проверок подписей вообще. 
Для загрузки неподписанных драйверов во время 
выполнения NTOSKRNL.EXE должен быть пропатчен. 
Но, патч ядра несет угрозу его цифровой подписи, 
следовательно, WINLOAD.EXE откажется загружать ядро.

\bigskip
{\bfseries Apple Seatbelt. }

Кроме возможности использования интерфейсов 
при программировании, позволяет помещать приложения 
в «песочницу», где их поведение будет контролироваться 
на основании определенных профилей. Данные профили 
находятся в /usr/share/sandbox и состоят из 
allow/deny определений и регулярных выражений 
для определения прав доступа к ресурсам системы. 
Объекты определяются по абсолютному пути (POSIX). 
Пример конфигурационного файла: 

\begin{flushleft}
\bigskip
\texttt{(version1)\\
(debug deny)\\
(allow default)\\
(allow process*)\\
(deny network-outbound)\\
(allow file-read-data file-read-metadata\\
(regex "\^ /.*"))\\
(deny file-write* \\
(regex "\^ /.*"))\\
(allow file-write*\\
(regex "\^ /Users/johndoe/Library/Preferences.*"))\\
(allow file-write* file-read-data file-read-metadata\\
(regex "\^ (/private)?/tmp/"))\\
(import "bsd.sb")
}
\bigskip
\end{flushleft}

Помещение в «песочницу» приложения на Cocoa производится следующим образом:
\% sandbox-exec -n localonly /Applications/TextEdit.app /Contents/MacOS/TextEdit

\end{comment}
